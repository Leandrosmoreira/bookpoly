"""
Data models for Claim Sweeper.
"""
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional
import time


class ClaimStatus(Enum):
    """Status of a claim attempt."""
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    RETRYING = "RETRYING"
    SKIPPED = "SKIPPED"  # Already claimed or not won


class ClaimType(Enum):
    """Type of claim."""
    REDEEM_WINNINGS = "REDEEM_WINNINGS"  # Won market
    REDEEM_LOSING = "REDEEM_LOSING"  # Lost market (0 payout, just cleanup)
    REFUND = "REFUND"  # Market cancelled


@dataclass
class ClaimItem:
    """
    Represents a claimable position.

    Generated by ClaimScanner when it finds positions in resolved markets.
    """
    # Unique identifier for this claim
    claim_id: str

    # Market info
    market_id: str  # condition_id
    market_slug: str  # e.g., "btc-15m-2024-02-08-21-00"
    token_id: str  # The outcome token we hold

    # Position info
    shares: float  # Number of shares we hold
    entry_price: float  # Price we paid per share

    # Resolution info
    won: bool  # Did we win?
    payout_per_share: float  # $1.00 if won, $0.00 if lost
    total_payout: float  # shares * payout_per_share

    # Timing
    resolved_at: int  # Unix timestamp when market resolved
    first_seen_at: int = field(default_factory=lambda: int(time.time()))

    # Metadata
    claim_type: ClaimType = ClaimType.REDEEM_WINNINGS
    side: str = ""  # "UP" or "DOWN"

    # For on-chain redemption
    outcome_index: int = 0  # 0 for first outcome (Up/Yes), 1 for second (Down/No)
    neg_risk: bool = False  # Whether market uses neg risk

    @property
    def expected_profit(self) -> float:
        """Expected profit from this claim (before fees)."""
        if self.won:
            return self.shares * (1.0 - self.entry_price)
        return -self.shares * self.entry_price

    @property
    def fee_amount(self) -> float:
        """Fee we pay for the SELL@0.99 workaround."""
        if self.won:
            return self.shares * 0.01  # $0.01 per share
        return 0.0

    @property
    def net_payout(self) -> float:
        """Net payout after fees."""
        if self.won:
            return self.shares * 0.99  # We get $0.99 per share
        return 0.0


@dataclass
class ClaimResult:
    """
    Result of a claim attempt.

    Returned by ClaimExecutor after attempting to claim.
    """
    success: bool

    # Identifiers
    claim_id: str = ""
    order_id: str = ""

    # Amounts
    amount_received: float = 0.0
    fee_paid: float = 0.0

    # Timing
    started_at: int = field(default_factory=lambda: int(time.time()))
    completed_at: int = 0
    duration_ms: int = 0

    # Status
    dry_run: bool = False
    error: str = ""
    retryable: bool = False

    # Raw response
    raw_response: dict = field(default_factory=dict)

    def __post_init__(self):
        if not self.completed_at:
            self.completed_at = int(time.time())
        if not self.duration_ms:
            self.duration_ms = (self.completed_at - self.started_at) * 1000


@dataclass
class ClaimEvent:
    """
    Event for JSONL logging.
    """
    ts: int
    event: str  # scan_start, scan_end, claim_attempt, claim_success, claim_failed
    claim_id: str = ""
    market_id: str = ""
    market_slug: str = ""
    token_id: str = ""
    shares: float = 0.0
    amount: float = 0.0
    fee: float = 0.0
    order_id: str = ""
    status: str = ""
    error: str = ""
    dry_run: bool = False

    def to_dict(self) -> dict:
        """Convert to dict for JSON serialization."""
        return {
            "ts": self.ts,
            "event": self.event,
            "claim_id": self.claim_id,
            "market_id": self.market_id,
            "market_slug": self.market_slug,
            "token_id": self.token_id,
            "shares": self.shares,
            "amount": self.amount,
            "fee": self.fee,
            "order_id": self.order_id,
            "status": self.status,
            "error": self.error,
            "dry_run": self.dry_run,
        }


@dataclass
class ClaimStats:
    """
    Statistics for a claim cycle.
    """
    cycle_start: int = field(default_factory=lambda: int(time.time()))
    cycle_end: int = 0

    # Counts
    scanned: int = 0
    claimable: int = 0
    attempted: int = 0
    success: int = 0
    failed: int = 0
    skipped: int = 0

    # Amounts
    total_payout: float = 0.0
    total_fees: float = 0.0

    @property
    def duration_s(self) -> float:
        """Cycle duration in seconds."""
        if self.cycle_end:
            return self.cycle_end - self.cycle_start
        return time.time() - self.cycle_start

    def to_dict(self) -> dict:
        return {
            "cycle_start": self.cycle_start,
            "cycle_end": self.cycle_end,
            "duration_s": self.duration_s,
            "scanned": self.scanned,
            "claimable": self.claimable,
            "attempted": self.attempted,
            "success": self.success,
            "failed": self.failed,
            "skipped": self.skipped,
            "total_payout": self.total_payout,
            "total_fees": self.total_fees,
        }
